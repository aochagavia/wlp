\documentclass[a4paper]{article}

\usepackage{xltxtra}
\usepackage{url}
\usepackage{polyglossia}
\usepackage{amsmath}
\setdefaultlanguage{english}

% Command to typeset ++
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-5mu+}}}

\author{
  Tim Baanen\\4134524
  \and
  Adolfo Ochagav√≠a\\4045483
}
\title{WLP Verification Tool}

\begin{document}

\maketitle

\section{Introduction}

Even after decades of software verification research, there are still serious
limitations to automated formal verification methods \cite{d2008survey}. A
possible alternative to these methods is automated testing, which in some cases
offers better scalability by giving up completeness.

Within the field of automated software testing, different approaches have been
tried. A relatively recent overview of the current state of affairs is
presented by Ammann \cite{ammann2008introduction}. In this project, we face
the problem of automated generation and running of test cases based on the
model of programs. Said models not only reflect the behavior of a given
program, but also provide assumptions and assertions that should be respected.

% Other examples of automated testing: fuzzers (American Fuzzy Lop) \cite{takanen2008fuzzing},
% or even QuickCheck to some extent

\section{The Verificaction Tool}

The verification tool implemented in this project models programs using a
variant of Dijkstra's Guarded Command Language (GCL) \cite{Dijkstra:gcl}.
The language supports assertions, which are treated as postconditions,
and assumptions, treated as preconditions.

Based on the GCL model of a program, our tool performs the following steps:

\begin{enumerate}
\item Calculate the possible execution paths up to a given length (performed by
the \texttt{path} function in \texttt{Lib.hs}).
\item For each path, calculate the WLP taking assumptions and assertions into account
(performed by the \texttt{wlp}, \texttt{wlp'} and \texttt{wlpPath} functions in \texttt{Lib.hs}).
\item For each WLP, calculate a QuickCheck \cite{claessen2011quickcheck} \texttt{Property}
(performed by the \texttt{testPredicate} function in \texttt{Lib.hs}).
\item For each \texttt{Property}, feed it to QuickCheck so it can be tested (see
\texttt{Spec.hs} for examples).
\end{enumerate}

The subsections below explain in detail each of the previous steps, except the last
one.

\subsection{Calculating execution paths}

Since our modeling language supports control flow constructs, a program may have
multiple execution paths depending on the initial values of the variables and
parameters. Furthermore, programs may loop infinitely and therefore can be traversed
by execution paths of infinite length. Given the undecidability of the halting
problem, we introduce an artificial length limit that a path is not allowed to exceed.

When calculating execution paths, we insert \texttt{assume} and \texttt{assert}
statements in order to drive the WLP calculation later on. Since they are not
really part of the execution path, they are ignored when determining its length.

Some constructs of the language are unrelated to control flow and therefore have
a trivial implementation of the $path$ function. It is the case of \texttt{Skip},
\texttt{Assert}, \texttt{Assume} and \texttt{Assign}. Other constructs, however,
affect control flow or at least contain other constructs that do. Below is a
description of how they are handled:

\subsubsection*{Variable declaration}

According to the grammar of GCL, variable declaration is always followed by a
statement. Therefore, we need to calculate the execution paths for the given
statement and append the variable declaration to each of them.

\subsubsection*{Sequence}

\texttt{Sequence} combines two statements in such a way that one is executed
after the other. Let $firstPaths$ be the set of possible execution paths for
the first statement and $lastPaths$ those for the second statement. Then, the
possible execution paths for \texttt{Sequence} are defined as:

\begin{align*}
	\text{Paths}(\text{first} ; \text{second}) &= \{ p_1 \mdoubleplus p_2 \mid p_1 \in \text{Paths}(\text{first}), p_2 \in \text{Paths}(\text{second})\}.
\end{align*}

\subsubsection*{If-then-else}

The if-then-else statement contains two statements, one for the \texttt{then} branch
and one for the \texttt{else} branch. Since only one of them will be executed
when the program is run, the paths for if-then-else are defined as:

\begin{align*}
	\text{Paths}(\texttt{if } \text{cond } \text{then } \text{else}) &= \text{Paths}(\text{then}) \cup \text{Paths}(\text{else}).
\end{align*}

Note, however, that we need to prepend an assumption of the condition for each
path in the \texttt{then} branch, and a negation thereof for each path in the
\texttt{else} branch. This is necessary to drive the WLP calculation later on.

\subsubsection*{While}

To calculate the paths in a while, we consider two situations:

\begin{itemize}
\item The condition is initially false
\item The condition is initially true, so the body and a new path through
the while loop are executed
\end{itemize}

By doing this recursively, we can obtain the paths in the body and unroll the
loop as much as possible:

\begin{align*}
	\text{Paths}(\texttt{while } \text{cond } \text{body}) &= \{[]\} \cup (\text{Paths}(\text{body}) \mdoubleplus \text{Paths}(\texttt{while } \text{cond } \text{body}) ).
\end{align*}

Of course, in our code we add a path length limit in order to prevent generation
of infinite paths. Additionally, in the case when the condition is initially false,
the body of the while is not executed so the path is empty. As in the
if-then-else paths, we use assumptions to control the state of the condition.

Note that we do not do a finite unfolding where we assert that the loop is
traversed a set number of times. Instead, we assume the number of loop
iterations for each path. If we used assertions instead of assumptions, the
checker would reject all loops. Given two paths with different iteration counts,
no (consistent) precondition would satisfy an assertion that both paths will
be executed, but there are preconditions that either path may be taken.

\subsubsection*{Program calls}

We handle program calls by including the code of the called program in a path.
The case of recursive calls is handled nicely by a combination of Haskell's
lazy evaluation semantics and the upper limit on the paths, which ensures no
infinitely long path will need to be generated.

However, we cannot directly inline a program that contains pre- and
postconditions. The calling function has the responsibility to satisfy these
conditions, and cannot simply pass the responsibility to its own caller.
Instead, we replace each assumption with an assertion and vice versa. As long
as all the called programs are correct, this implies the calling program is
correct as well. We could also drop all assertions in the called program, but
we chose not to do so, as recursive calls might benefit from them.

\subsection{Calculating WLP}

The implementation of WLP for \texttt{Skip}, \texttt{Sequence}, \texttt{Assume}
and \texttt{Assert} is either trivial or recursively defined. However, the
implementations for \texttt{Assign} and \texttt{Var} are less straightforward.

\subsubsection*{Var}

The WLP of a \texttt{Var} statement is equivalent to the WLP of its inner statement.
This seems trivial at first, but we need to consider the fact that the declared
variables may be shadowing already existing names. In order to avoid that, we
rename all declared variables that shadow existing names in such a way that they get
a unique one. This is done by the \texttt{refresh} function (defined in \texttt{Rewriting.hs}).

% Idea: write an appendix telling more about how refresh works?

\subsubsection*{Assign}

The WLP of assignment involves replacing names by expressions in the postcondition.
When the target of the assignment is a name, we replace the given name by the value
of the assignment. When the target is an array, we replace the index by an appropriate
\texttt{Repby}. Refer to the \texttt{replace} function for the concrete implementation
details of the replacing algorithm (defined in \texttt{Rewriting.hs}).

\subsection{Calculating QuickCheck properties}

The output of the WLP step is a GCL expression that should evaluate to a boolean
after instantiating the free variables. Constructing a QuickCheck \texttt{Property}
based on the WLP is achieved through the following steps:

\begin{enumerate}
\item Normalize the WLP
\item Calculate the ranges
\item Generate sets of variable instantiations
\item Ensure that the WLP holds for all sets of variable instantiations
\end{enumerate}

A detailed explanation of the workings of each step is provided below.

\subsubsection*{Normalize WLP}

We rewrite the predicate in the prenex normal form. After normalization, the
predicate will start with a string of quantifiers, followed by a quantifier-free
formula. Since we find a counterexample to the predicate by checking various
instantiations of the quantifiers, normalizing will show exactly which
quantifiers need to be instantiated.

By discarding all universal quantifiers in front of the WLP, we do not have to
handle these seperately, but as free variables. A formula without quantifiers
and instantiations for all free variables is very easy to decide, while many
formulae with quantifiers are undecidable.

Additionally, we do some rewriting on the predicate to simplify it. These steps
include removing double negations and reducing expressions with constants,
such as $\phi \vee \bot$, to simpler expressions such as $\phi$.

\subsubsection*{Calculate Ranges}

We need QuickCheck to generate only relevant test cases. That is, test cases that
are likely to make the program fail. When the precondition does not hold
for the example we want to consider, there is no way to make the program fail.
Similarly, when the postcondition always holds, there is no need to search for
preconditions that make the postcondition fail. Therefore, we consider a test
case irrelevant when it satisfies either:

\begin{itemize}
\item Invalid precondition
\item Trivial postcondition
\end{itemize}

Therefore, we introduce the concept of ranges. A range represents the set of
values that a variable can take, while still satisfying the previous requirements.
Initially, all free variables get an infinite range, which is then partially narrowed.
Because complete narrowing would be equivalent to SAT solving, we only consider
relatively simple cases.

As an example, let us consider the ranges that would be generated for the following WLP
expression:

\[ ((0 \leq k \leq 10) \wedge (x = y) \wedge p) \Rightarrow q \]

It is clear that we want to generate a $k$ in the range $[0, 10]$, the value of
$x$ to be equal to $y$ and a $p$ that is \texttt{True}. In any other case, the
left side of the implication cannot be true and the whole expression will
trivially evaluate to \texttt{True}.

From the ranges we have constructed for the variables, we make QuickCheck
generators that generate values in the corresponding ranges. If the range turns
out to be empty for some variable, QuickCheck will raise an error. Therefore
we need to check that the ranges are non-empty before turning them into generators.

\subsubsection*{Ensure that the WLP holds for all sets of variable instantiations}

In this step we construct a \texttt{Property} that takes the input generated by
the previous generator, feeds it to the WLP and ensures that it holds.

In case any of the ranges is empty, we know that the precondition cannot be
satisfied or the postcondition is always satisfied. This means that the
\texttt{Property} always holds, and we immediately report a success.

However, in most cases, the ranges are not empty and we try to find a counterexample
based on the generated instantiations. That is, for each generated set of variable
instantiations, we test to see if the calculated WLP holds.

The test is performed by the \texttt{runCase} function, which returns \texttt{True}
when the WLP is found to be valid and \texttt{False} otherwise. The function
operates in two steps:

\begin{enumerate}
\item Ensure that all expressions in an assignment target are evaluated (performed
by the \texttt{literalize} function). This ensures array indexing is performed
consistently, so $a[i]$ and $a[j]$ will always be the same value if $i = j$.
\item Evaluate the WLP with the given variable instantiations (performed by the
\texttt{evaluateClosed} function in \texttt{Eval.hs}).
\end{enumerate}

\section{Results}

At least discuss the examples that you are requested
to solve, and how you solve them.

\section{Related Work}

TODO

\section{Conclusion}

Best conclusion ever

\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}
