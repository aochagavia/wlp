\documentclass[a4paper]{article}

\usepackage{xltxtra}
\usepackage{url}
\usepackage{polyglossia}
\setdefaultlanguage{english}

% Command to typeset ++
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-5mu+}}}

\author{
  Tim Baanen\\4134524
  \and
  Adolfo Ochagav√≠a\\4045483
}
\title{WLP Verification Tool}

\begin{document}

\maketitle

\section{Introduction}

Even after decades of software verification research, there are still serious
limitations to automated formal verification methods \cite{d2008survey}. A
possible alternative to these methods is automated testing, which in some cases
offers better scalability by renouncing to completeness.

Within the field of automated software testing, different approaches have been
tried. A relatively recent overview of the current state of affairs is
presented by Ammann \cite{ammann2008introduction}. In this project, we face
the problem of automated generation and running of test cases based on the
model of programs. Said models not only reflect the behavior of a given
program, but also provide assumptions and assertions that should be respected.

% Other examples of automated testing: fuzzers (American Fuzzy Lop) \cite{takanen2008fuzzing},
% or even QuickCheck to some extent

\section{The Verificaction Tool}

The verification tool implemented in this project models programs using a
variant of Dijkstra's Guarded Command Language (GCL) \cite{Dijkstra:gcl}.
The language supports assertions, which are treated as postconditions,
and assumptions, treated as preconditions.

Based on the GCL model of a program, our tool performs the following steps:

\begin{enumerate}
\item Calculate the possible execution paths up to a given length (performed by
the \texttt{path} function in \texttt{Lib.hs}).
\item For each path, calculate the WLP taking assumptions and assertions into account
(performed by the \texttt{wlp}, \texttt{wlp'} and \texttt{wlpPath} functions in \texttt{Lib.hs}).
\item For each WLP, calculate a QuickCheck \cite{claessen2011quickcheck} \texttt{Property}
(performed by the \texttt{testPredicate} function in \texttt{Lib.hs}).
\item For each \texttt{Property}, feed it to QuickCheck so it can be tested (see
\texttt{Spec.hs} for examples).
\end{enumerate}

The subsections below explain in detail each of the previous steps.

\subsection{Calculating execution paths}

Since our modeling language supports control flow constructs, a program may have
multiple execution paths depending on the initial values of the variables and
parameters. Furthermore, programs may loop infinitely and therefore can be traversed
by execution paths of infinite length. Given the undecidability of the halting
problem, we introduce an artificial length limit that a path is not allowed to exceed.

When calculating execution paths, we insert \texttt{assume} and \texttt{assert}
statements in order to drive the WLP calculation later on. Since they are not
really part of the execution path, they are ignored when determining its length.

Some constructs of the language are unrelated to control flow and therefore have
a trivial implementation of the $path$ function. It is the case of \texttt{Skip},
\texttt{Assert}, \texttt{Assume} and \texttt{Assign}. Other constructs, however,
affect control flow or at least contain other constructs that do. Below is a
description of how they are handled:

\subsubsection*{Variable declaration}

According to the grammar of GCL, variable declaration is always followed by a
statement. Therefore, we need to calculate the execution paths for the given
statement and append the variable declaration to each of them.

\subsubsection*{Sequence}

\texttt{Sequence} combines two statements in such a way that one is executed
after the other. Let $firstPaths$ be the set of possible execution paths for
the first statement and $lastPaths$ those for the second statement. Then, the
possible execution paths for \texttt{Sequence} are defined as:

\[ Paths(Sequence) = \{ p_1 \mdoubleplus p_2 | p_1 \in firstPaths, p_2 \in lastPaths\} \]

\subsubsection*{If-then-else}

The if-then-else statement contains two statements, one for the \texttt{then} branch
and one for the \texttt{else} branch. Since only one of them will be executed
when the program is run, the paths for if-then-else are defined as:

\[ Paths(IfThenElse) = Paths(then) \cup Paths(else) \]

% The paragraph below refers to an implementation detail. Should we include it
% or leave it? I already say in the beginning of the subsection that we introduce
% assumes and asserts to drive the WLP calculation later on. Conceptually, they don't
% seem to be part of the path.
%
% Note, however, that we need to prepend an assumption of the if condition for each
% path in the \texttt{then} branch, and a negation thereof for each path in the
% \texttt{else} branch. This is necessary to drive the WLP calculation later on.

\subsubsection*{While}

When calculating the paths in a while we assume that the condition is true
after each iteration. By doing this, we can obtain the paths in the body and
unroll the loop as much as possible:

\[ Paths(While) = \{ p_{body} \mdoubleplus p_{while} | p_{body} \in Paths(body), p_{while} \in Paths(While)\} \]

Of course, in our code we add a path length limit in order to prevent generation
of infinite paths. We also add a path in which the condition is false. In that
case, the body of the while is not executed so the path is empty.

FIXME: wouldn't it be more correct to do finite unfolding as explained in the lectures?
Currently we are assuming that the condition holds after each iteration, which is not realistic

\subsection{Calculating WLP}

The implementation of WLP for \texttt{Skip}, \texttt{Sequence}, \texttt{Assume}
and \texttt{Assert} is either trivial or recursively defined. However, the
implementations for \texttt{Assign} and \texttt{Var} are less straightforward.

\subsubsection*{Var}

The WLP of a \texttt{Var} statement is equivalent to the WLP of its inner statement.
This seems trivial at first, but we need to consider the fact that the declared
variables may be shadowing already existing names. In order to avoid that, we
rename all declared variables that shadow existing names in such a way that they get
a unique one. This is done by the \texttt{refresh} function (defined in \texttt{Rewriting.hs}).

% Idea: write an appendix telling more about how refresh works?

\subsubsection*{Assign}

The WLP of assignment involves replacing names by expressions in the postcondition.
When the target of the assignment is a name, we replace the given name by the value
of the assignment. When the target is an array, we replace the index by an appropriate
\texttt{Repby}. Refer to the \texttt{replace} function for the concrete implementation
details of the replacing algorithm (defined in \texttt{Rewriting.hs}).

\subsection{Calculating QuickCheck properties}

The output of the WLP step is a first order logic expression. Afterwards, we
need to ensure that said expression is always true.

\begin{enumerate}
\item Normalize the predicate
\item Calculate the ranges
\item Create QuickCheck generators based on the ranges
\end{enumerate}

\subsection{Feeding to QuickCheck}

Trivial?

\section{Results}

At least discuss the examples that you are requested
to solve, and how you solve them.

\section{Related Work}

TODO

\section{Conclusion}

Best conclusion ever

\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}
