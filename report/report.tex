\documentclass[a4paper]{article}

\usepackage{xltxtra}
\usepackage{url}
\usepackage{polyglossia}
\usepackage{amsmath}
\setdefaultlanguage{english}

% Command to typeset ++
\newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-5mu+}}}

\author{
  Tim Baanen\\4134524
  \and
  Adolfo Ochagav√≠a\\4045483
}
\title{WLP Verification Tool}

\begin{document}

\maketitle

\section{Introduction}

Even after decades of software verification research, there are still serious
limitations to automated formal verification methods \cite{d2008survey}. A
possible alternative to these methods is automated testing, which in some cases
offers better scalability by giving up completeness.

Within the field of automated software testing, different approaches have been
tried. A relatively recent overview of the current state of affairs is
presented by Ammann \cite{ammann2008introduction}. In this project, we face
the problem of automated generation and running of test cases based on the
model of programs. Said models not only reflect the behavior of a given
program, but also provide assumptions and assertions that should be respected.

% Other examples of automated testing: fuzzers (American Fuzzy Lop) \cite{takanen2008fuzzing},
% or even QuickCheck to some extent

\section{The Verificaction Tool}

The verification tool implemented in this project models programs using a
variant of Dijkstra's Guarded Command Language (GCL) \cite{Dijkstra:gcl}.
The language supports assertions, which are treated as postconditions,
and assumptions, treated as preconditions.

Based on the GCL model of a program, our tool performs the following steps:

\begin{enumerate}
\item Calculate the possible execution paths up to a given length (performed by
the \texttt{path} function in \texttt{Lib.hs}).
\item For each path, calculate the WLP taking assumptions and assertions into account
(performed by the \texttt{wlp}, \texttt{wlp'} and \texttt{wlpPath} functions in \texttt{Lib.hs}).
\item For each WLP, calculate a QuickCheck \cite{claessen2011quickcheck} \texttt{Property}
(performed by the \texttt{testPredicate} function in \texttt{Lib.hs}).
\item For each \texttt{Property}, feed it to QuickCheck so it can be tested (see
\texttt{Spec.hs} for examples).
\end{enumerate}

The subsections below explain in detail each of the previous steps, except the last
one.

\subsection{Calculating execution paths}

Since our modeling language supports control flow constructs, a program may have
multiple execution paths depending on the initial values of the variables and
parameters. Furthermore, programs may loop infinitely and therefore can be traversed
by execution paths of infinite length. Given the undecidability of the halting
problem, we introduce an artificial length limit that a path is not allowed to exceed.

When calculating execution paths, we insert \texttt{assume} and \texttt{assert}
statements in order to drive the WLP calculation later on. Since they are not
really part of the execution path, they are ignored when determining its length.

Some constructs of the language are unrelated to control flow and therefore have
a trivial implementation of the $path$ function. This is the case for
\texttt{Skip}, \texttt{Assert}, \texttt{Assume} and \texttt{Assign}. Other
constructs, however, affect control flow or at least contain other constructs
that do. Below is a description of how they are handled:

\subsubsection*{Variable declaration}

According to the grammar of GCL, variable declaration is always followed by a
statement in its scope. Therefore, we need to calculate the execution paths for
the given statement and append the variable declaration to each of them.

\subsubsection*{Sequence}

\texttt{Sequence} combines two statements in such a way that one is executed
after the other. This means we need to combine the paths of either statement
to get the path through the sequenced statements. Formally, the possible
execution paths for \texttt{Sequence} are defined as:
\begin{align*}
	\text{Paths}(\text{first} ; \text{second}) &= \{ p_1 \mdoubleplus p_2 \mid p_1 \in \text{Paths}(\text{first}), p_2 \in \text{Paths}(\text{second})\}.
\end{align*}

\subsubsection*{If-then-else}

The if-then-else statement contains two statements, one for the \texttt{then} branch
and one for the \texttt{else} branch. Since only one of them will be executed
when the program is run, the paths for if-then-else are defined as:
\begin{align*}
	\text{Paths}(\texttt{if } \text{cond } \text{then } \text{else}) &= \text{Paths}(\text{then}) \cup \text{Paths}(\text{else}).
\end{align*}

Note, however, that we need to prepend an assumption of the condition for each
path in the \texttt{then} branch, and a negation thereof for each path in the
\texttt{else} branch. This is necessary to drive the WLP calculation later on.

\subsubsection*{While}

If the while loop is annotated with an invariant, we can use it directly in the
WLP calculation. However, if the loop is not annotated, we must supply our own
precondition for the given postcondition. To do this using a list of program
paths, we consider two situations:

\begin{itemize}
\item The condition is initially false
\item The condition is initially true, so the body and a new path through
the while loop are executed
\end{itemize}

By doing this recursively, we can obtain the paths in the body and unroll the
loop as much as possible:
\begin{align*}
	\text{Paths}(\texttt{while } \text{cond } \text{body}) &= \{[]\} \cup (\text{Paths}(\text{body}) \mdoubleplus \text{Paths}(\texttt{while } \text{cond } \text{body}) ).
\end{align*}

Of course, in our code we add a path length limit in order to prevent generation
of infinite paths. Additionally, in the case when the condition is initially false,
the body of the while is not executed so the path is empty. As in the
if-then-else paths, we use assumptions to control the state of the condition.

Note that we do not do a finite unfolding where we assert that the loop is
traversed a set number of times. Instead, we assume the number of loop
iterations for each path. If we used assertions instead of assumptions, the
checker would reject all loops. Given two paths with different iteration counts,
no (consistent) precondition would satisfy an assertion that both paths will
be executed, but there are preconditions that either path may be taken.

\subsubsection*{Program calls}

We handle program calls by including the code of the called program in a path.
The case of recursive calls is handled nicely by a combination of Haskell's
lazy evaluation semantics and the upper limit on the paths, which ensures no
infinitely long path will need to be generated.

However, we cannot directly inline a program that contains pre- and
postconditions. The calling function has the responsibility to satisfy these
conditions, and cannot simply pass the responsibility to its own caller.
Instead, we drop all assertions and assumptions in the called program. Note
that we do keep the assumptions generated by generation of program paths.

\subsection{Calculating WLP}

The implementation of WLP for \texttt{Skip}, \texttt{Sequence}, \texttt{Assume}
and \texttt{Assert} is either trivial or recursively defined. However, the
implementations for \texttt{Assign} and \texttt{Var} are less straightforward.

\subsubsection*{Var}

The WLP of a \texttt{Var} statement is equivalent to the WLP of its inner
statement. This seems trivial at first, but we need to consider the fact that
the declared variables may be shadowing already existing names. In order to
avoid that, we rename all declared variables that shadow existing names in
such a way that they get a unique one. This is done by the \texttt{refresh}
function (defined in \texttt{Rewriting.hs}). Then we apply the $\forall$
quantifier to any remaining variables.

% Idea: write an appendix telling more about how refresh works?

\subsubsection*{Assign}

The WLP of assignment involves replacing names by expressions in the postcondition.
When the target of the assignment is a name, we replace the given name by the value
of the assignment. When the target is an array, we replace the index by an appropriate
\texttt{Repby}. Refer to the \texttt{replace} function for the concrete implementation
details of the replacing algorithm (defined in \texttt{Rewriting.hs}).

\subsubsection*{While with invariant}

The WLP of a while loop with an invariant is the invariant itself, provided the
invariant is a valid one in the context of the postcondition. However, checking
this constraint requires that we actually test the body of the loop, which
would make the tester depend on itself recursively. Therefore, we assume the
user supplies the correct invariant.

\subsection{Calculating QuickCheck properties}

The output of the WLP step is a GCL expression that should evaluate to a boolean
after instantiating the free variables. Constructing a QuickCheck \texttt{Property}
based on the WLP is achieved through the following steps:

\begin{enumerate}
\item Normalize the WLP
\item Calculate the ranges
\item Generate sets of variable instantiations
\item Ensure that the WLP holds for all sets of variable instantiations
\end{enumerate}

A detailed explanation of the workings of each step is provided below.

\subsubsection*{Normalize WLP}

We rewrite the predicate in the prenex normal form. After normalization, the
predicate will start with a string of quantifiers, followed by a quantifier-free
formula. Since we find a counterexample to the predicate by checking various
instantiations of the quantifiers, normalizing will show exactly which
quantifiers need to be instantiated.

By discarding all universal quantifiers in front of the WLP, we do not have to
handle these separately, but as free variables. A formula without quantifiers
and instantiations for all free variables is very easy to decide, while many
formulas with quantifiers are undecidable.

Additionally, we do some rewriting on the predicate to simplify it. These steps
include removing double negations and reducing expressions with constants,
such as $\phi \vee \bot$, to simpler expressions such as $\phi$.

\subsubsection*{Calculate Ranges}

We need QuickCheck to generate only relevant test cases. That is, test cases that
are likely to make the program fail. When the precondition does not hold
for the example we want to consider, there is no way to make the program fail.
Similarly, when the postcondition always holds, there is no need to search for
preconditions that make the postcondition fail. Therefore, we consider a test
case irrelevant when it satisfies either:

\begin{itemize}
\item Invalid precondition
\item Trivial postcondition
\end{itemize}

Therefore, we introduce the concept of ranges. By restricting a variable to a
well-chosen range, we need to consider less test cases but still receive an
equivalent predicate. Initially, all free variables get an infinite range, which
is then partially narrowed. Because complete narrowing would be equivalent to
SAT solving, we only consider relatively simple cases.

As an example, let us consider the ranges that would be generated for the following WLP
expression:

\begin{align*}
	((0 \leq k \leq 10) \wedge (x = y) \wedge p) \Rightarrow (q \wedge \exists n (1 \leq n \leq 5)).
\end{align*}

It is clear that we want to generate a $k$ in the range $[0, 10]$, the value of
$x$ to be equal to $y$ and a $p$ that is \texttt{True}. In any other case, the
left side of the implication cannot be true and the whole expression will
trivially evaluate to \texttt{True}. Moreover, we want $q$ to be \texttt{False}
to find a counterexample on the right side of the implication. Note however that
the range for $n$ is $[1, 5]$, since it suffices to (fully) check this range to
find a contradiction. The function \texttt{nonTrivRange} calculates these
ranges.

From the ranges we have constructed for the variables, we make QuickCheck
generators that generate values in the corresponding ranges. If the range turns
out to be empty for some variable, QuickCheck will raise an error. Therefore
we need to check that the ranges are non-empty before turning them into generators.

\subsubsection*{Ensure that the WLP holds for all sets of variable instantiations}

In this step we construct a \texttt{Property} that takes the input generated by
the previous generator, feeds it to the WLP and ensures that it holds.

In case any of the ranges is empty, we know that the precondition cannot be
satisfied or the postcondition is always satisfied. This means that the
\texttt{Property} always holds. 

However, in most cases, the ranges are not empty and we try to find a counterexample
based on the generated instantiations. That is, for each generated set of variable
instantiations, we test to see if the calculated WLP holds.

The test is performed by the \texttt{runCase} function, which returns \texttt{True}
when the WLP is found to be valid and \texttt{False} otherwise. The function
operates in two steps:

\begin{enumerate}
\item Ensure that all expressions in an assignment target are evaluated (performed
by the \texttt{literalize} function). This ensures array indexing is performed
consistently, so $a[i]$ and $a[j]$ will always be the same value if $i = j$.
\item Evaluate the WLP with the given variable instantiations (performed by the
\texttt{evaluateClosed} function in \texttt{Eval.hs}).
\end{enumerate}

When evaluating the WLP expression there are three possibilities:

\begin{enumerate}
\item The expression starts with a universal quantifier or has a variables:
we try to instantiate the variables to find a counterexample. If we find one, we
are sure the predicate does not always hold. If we do not find one, we can only
conclude that there probably is no counterexample that can be found easily.
\item The expression starts with an existential quantifier: we try to instantiate
the variables to find an example. As with the universal quantifier, we can only
be sure of finding an example, and we interpret the failure in a weak sense.
\item There are no quantifiers: this means that all variables should have been
instantiated. In this case, we directly evaluate the WLP for the given
instantiations, and be sure about the outcome.
\end{enumerate}

Unfortunately, QuickCheck is designed around universal quantification, which means
that it provides no straightforward way to deal with existential quantifiers.
For this reason, we had to extend QuickCheck with additional types and functions
in order to meet our needs.

\section{Results}

Example E (base implementation)

minind (base implementation)

swap (array assignment)

sort (program call)

loop with invariant

Non-determinism! Sometimes a test produces the expected result, and sometimes it doesn't!
Sound, but definitely not complete.

\section{Related Work}

TODO

\section{Conclusion}

The resulting verification tool is sound but incomplete.

There is still the question if there is a reliable method of generating a GCL
specification to test.

Limitations: existential quantification, ...

\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}
